Harden ASSL Chatbot Retrieval + Player Q&A (Nano-Safe)
Objectives

Never show “I don’t have that in my documents” for basic questions: add a smart fallback that always returns helpful sections.

Surface tournament dates and other high-intent topics with intent routing.

Keep CURRENT_OPENAI_MODEL = "gpt-5-nano" using Responses API (instructions, input, max_output_tokens only).

Prepare the bot to answer common player/manager/fan questions out of the box.

0) Sanity (no code change)

Function entry points to the optimized handler: netlify/functions/chatbot.js → ./src/handler.js. Keep this. 

chatbot

Handler is already nano-safe and has robust extraction + guardrail. Keep this. 

handler

System prompt is slim and includes the guardrail. Keep this. 

prompt

1) Retrieval: add fallback + expand intent routing

Edit: netlify/functions/src/retrieval.js
Replace the file contents with the version below (adds CORE fallback for basics, expands routing):

// netlify/functions/src/retrieval.js
import { SECTIONS } from "./league-content.js";

// Core sections to fall back to when matching is weak.
// Put player-helpful content first.
const CORE_IDS = ["rules-faq", "rules", "tournament", "about", "links", "ratings", "board"];

const SYNONYMS = {
  "home run": ["home runs", "homer", "hr", "dinger", "over the fence"],
  "tiebreaker": ["international tiebreaker", "extra innings", "one-pitch"],
  "location": ["field", "fields", "where do you play", "ala wai", "crane"],
  "photos": ["gallery", "pictures", "eric z martin"],
  "schedule": ["standings", "teamsideline", "games", "when do we play"],
  "ratings": ["division", "skill", "tryout", "scrimmage", "ipride"],
  "uniforms": ["jersey", "shirt", "numbers", "dress code"],
  "bats": ["bat list", "approved bats", "equipment"],
  "contact": ["board", "email", "director", "commissioner"],
  "tournament": ["anuenue", "classic", "event", "dates", "when", "registration"]
};

function expandQuery(q) {
  const base = (q || "").toLowerCase();
  const extras = [];
  for (const [root, vals] of Object.entries(SYNONYMS)) {
    if (base.includes(root) || vals.some(v => base.includes(v))) extras.push(root, ...vals);
  }
  return Array.from(new Set([base, ...extras]));
}

function scoreSection(s, terms, phrase) {
  const hay = `${s.title}\n${s.text}\n${(s.tags || []).join(" ")}`.toLowerCase();
  let score = 0;
  for (const t of terms) if (t && hay.includes(t)) score += 2;          // word hits
  if (phrase && hay.includes(phrase.toLowerCase())) score += 3;         // phrase hit
  const tagset = new Set((s.tags || []).map(t => t.toLowerCase()));
  for (const t of terms) if (tagset.has(t)) score += 1;                 // tag bonus
  return score;
}

export function getRelevantSections(query, { maxSections = 3, maxChars = 2500 } = {}) {
  const q = (query || "").trim();
  const terms = expandQuery(q);

  // Intent: force-include certain sections
  const force = [];

  // Tournament routing
  if (/(tournament|anuenue|classic|event|date|dates|when|registration)/i.test(q)) {
    const t = SECTIONS.find(s => s.id === "tournament");
    if (t) force.push(t);
  }

  // Home run / rules routing
  if (/(home\s*run|hr|over[-\s]*the[-\s]*fence)/i.test(q)) {
    const rfaq = SECTIONS.find(s => s.id === "rules-faq");
    const rules = SECTIONS.find(s => s.id === "rules");
    for (const sec of [rfaq, rules]) if (sec && !force.includes(sec)) force.push(sec);
  }

  // Location, photos, schedule, ratings, contact
  const intents = [
    { re: /(field|fields|where|location|ala\s*wai|crane)/i, id: "locations" },
    { re: /(photo|gallery|picture|eric\s*z|eric\s*z\s*martin)/i, id: "photos" },
    { re: /(schedule|standings|teamsideline|games|when do we play)/i, id: "links" },
    { re: /(rating|division|skill|scrimmage|ipride)/i, id: "ratings" },
    { re: /(contact|board|commissioner|email)/i, id: "board" },
    { re: /(uniform|jersey|number)/i, id: "rules" },
    { re: /(bat|equipment)/i, id: "rules" }
  ];
  for (const { re, id } of intents) {
    if (re.test(q)) {
      const sec = SECTIONS.find(s => s.id === id);
      if (sec && !force.includes(sec)) force.push(sec);
    }
  }

  // Score remaining sections
  const scored = SECTIONS.map(s => ({ s, score: scoreSection(s, terms, q) }));

  const forcedIds = new Set(force.map(x => x.id));
  let rest = scored
    .filter(x => !forcedIds.has(x.s.id))
    .filter(x => x.score > 0)
    .sort((a, b) => b.score - a.score)
    .map(x => x.s);

  // *** CRITICAL FALLBACK ***
  // If nothing matched and nothing was forced, include CORE sections so basic Qs never produce empty context.
  if (force.length === 0 && rest.length === 0) {
    rest = CORE_IDS.map(id => SECTIONS.find(s => s.id === id)).filter(Boolean);
  }

  const top = [...force, ...rest].slice(0, maxSections);
  let out = top.map(s => `### ${s.title}\n${s.text}`).join("\n\n");
  if (out.length > maxChars) out = out.slice(0, maxChars) + "\n…";
  return out;
}


Why: your current retrieval.js returns nothing when no keywords match, which makes the handler send the “I don’t have that” message. This adds reliable routing and an all-season fallback for basic questions. 

retrieval

2) Content builder: keep using the generated sections (dates included)

No change required — your generated content already includes tournament dates and other key sections. 

league-content

 

league-content


If you later tweak MD structure/front-matter, ensure your build script regenerates league-content.js before bundling.

3) System prompt & handler (keep as-is)

prompt.js is concise, includes the guardrail, precedence policy, and “no Division B”. Keep. 

prompt

handler.js is nano-safe and extracts output robustly; the guardrail message only triggers on empty context, which step #1 fixes. Keep. 

handler

chatbot.js correctly imports the optimized handler. Keep. 

chatbot

4) Make the bot ready for real questions (intent routing just added)

The retrieval now front-loads the right sections when a user asks about:

Tournament (dates, venue, registration) → tournament + links. 

league-content

Home runs / rules / tiebreaker / time limit / lineups → rules + rules-faq. 

league-content

Where do you play? → locations (Ala Wai; Crane Field). 

league-content

Photos → photos (Eric Z Martin). 

league-content

Schedule/standings → links (TeamSideline). 

league-content

Ratings / divisions → ratings (C/D/E only; iPride rubric; no Division B). 

league-content

Contact the Board → board. (Emails and roles are present; adjust if needed.)

These are common, high-intent questions from players, captains, and spectators; the new router ensures the right chunks are always in CONTEXT.

5) Quick smoke tests (paste into Replit “Shell” or run via your UI)

Tournament: “When is the Anuenue Classic?” → must mention March 27–29, 2026. (Data exists in tournament and about.) 

league-content

 

league-content

Home runs: “What are the home run limits?” → C: 1; D/E: 0. 

league-content

Time limit: “When does the last inning start?” → “No new inning after 50:00”. 

league-content

Tiebreaker: “How do extra innings work?” → one-pitch 3/2, no courtesy foul; last batter on 2B. 

league-content

Where do you play? → Ala Wai Community Park; scrimmages at Crane Field (link). 

league-content

Photos: “Where can I see game photos?” → Eric Z Martin site + Season 4 collection. 

league-content

Ratings: “How are divisions assigned?” → iPride 26-question rubric; C/D/E only; restrictions. 

league-content

Contact: “How do I contact the league?” → Board roles/emails. (Present under board.)

6) (Optional) Enhance user friendliness

If a message is very short (e.g., “hi”, “hello”), you can prepend a tiny greeting before answering the detected intent (still using only CONTEXT). This lives in the handler logic (pre-prompt), but the fallback in retrieval already prevents the “no documents” reply for such basics.